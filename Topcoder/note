tco122A
500pt - DP
首先需要发现答案都在点上
然后观察答案和传输点的关系发现可以由左向右递推

tco122B
500pt - DP
首先需要发现若固定初始选则的book，则双方的最优策略是固定的
接下来预处理出第几大weight的book属于谁，然后就是一个简单的DP
	
tco122C
500pt - 数据结构
可以发现问题可以反面考虑一下
900pt - 想法
可以发现每一次转移的改变只发生在某个正数成了0,某个负数成了1
我们加速模拟这个过程
然后可以发现一个数只要变成了0或者1,就只会在之间振荡
最多n^2次就会收敛到都是0,1或者都是正数，或者都是负数(不会证明。。)

tco152A
300pt - DP计算
发现计算可以递归成子问题

tco152B
250pt - DP概率
水题

tco152C
500pt - 搜索
观察对比差分约束系统发现若我们确定人员谁坐谁不坐，以及坐的位置的顺序，我们就可以确定该组解是否存在
那么就直接枚举之后跑差分约束
另外一种petr的做法，定义了一个奇怪的树结构做为当前搜索的状态，这个状态抽象的功力实在高

srm500
500pt - 递归
分形，我们可以通过坐标缩放，坐标旋转将这一步的未结束线转为子问题
又因为问题都是整数，所以递归层数很浅

srm600
500pt - DP枚举
若我们枚举所有行是否为回文串的状态
那么接下来按列可以做一个递归的子问题

srm620
500pt - 想法
观察发现我们只有n-1组限制，而每选择一列的优先级就能去掉一些限制

srm661
500pt - 想法
观察发现mo数很小，答案会根据模数循环

srm666
500pt - DP
直接给当前permutation选定第一个数，就可以递归子问题了

srm669
500pt - 图论+数学
样例的解释直接就诱导你使用错误的解法..直接奇偶分类
然而并是错的，假设我有一条0到1的路径上有长度为x，y的环，那么就是ax+by+K=N是否有解(N足够大)，这个显然要求gcd(a,b)=1
因为题目要求0到1,且1到0,所以我们假设解存在的话，所有环都能串到一起，我们的目标变为求所有长度的0到1路上的环
然而有向图的简单环是n!级的。。
我们从另一个方面考虑，其实要INF就是某个剩余系下的每一种长度都可行，我们取这个剩余系为mod经过起点的最大简单环，然后暴力
[以上为口胡。。然而我还是不会。。]


1000pt - DP
研究一下给出的规律，发现我们要从']'走出来必须要0，然后设计DP的时候不小心递归错了。。
这个递归分十分多种情况考虑而已。。我们用dp[len][s][t]表示len长度，开始值是s，结束至是t，没有死循环的方案数
'+' or '-'的转移很简单，'['的转移就是枚举这个'[]'的长度，'[]'内又是一个新的递归
我们再用gao[len][s][ok]表示len长度，开始值是s，结尾是否必须为0,可以出这个循环的方案数
若'[]'的ed不为0，则'[]'内必须只有+-，这一部分我们简单DP预处理即可
若'[]'的ed为0,那么我们现在终于可以递归处理了。。（找到完全的子问题不容易。。）

